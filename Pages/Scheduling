
import React, { useState, useEffect } from 'react';
import { Settlement } from '@/entities/Settlement';
import { TaskType } from '@/entities/TaskType';
import { Contractor } from '@/entities/Contractor';
import { ContractorAvailability } from '@/entities/ContractorAvailability';
import { Appointment } from '@/entities/Appointment';
import { BlackoutDate } from '@/entities/BlackoutDate';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Checkbox } from '@/components/ui/checkbox';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Skeleton } from '@/components/ui/skeleton';
import { Badge } from '@/components/ui/badge';
import { Loader2, UserCheck, Sparkles, Wand2, Calendar as CalendarIcon, Star, Clock, ShieldAlert, CalendarX, CalendarDays } from 'lucide-react';
import { createPageUrl } from '@/utils';
import { usePermissions } from '../components/auth/PermissionGate';

const ManualScheduler = ({ contractors, settlements, taskTypes, onAppointmentCreated, contractorAvailabilities, appointments }) => {
    const [manualData, setManualData] = useState({
        contractorId: '',
        settlementName: '',
        taskType: '',
        date: '',
        timeSlot: '08:00-10:00'
    });
    const [isCreating, setIsCreating] = useState(false);

    // Helper to parse HH:MM string to minutes from midnight
    const parseTimeToMinutes = (timeStr) => {
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    };

    // Helper function to check for time slot overlap
    const checkTimeSlotOverlap = (slot1, slot2) => {
        const [s1_start_str, s1_end_str] = slot1.split('-');
        const [s2_start_str, s2_end_str] = slot2.split('-');

        const s1_start = parseTimeToMinutes(s1_start_str);
        const s1_end = parseTimeToMinutes(s1_end_str);
        const s2_start = parseTimeToMinutes(s2_start_str);
        const s2_end = parseTimeToMinutes(s2_end_str);

        // Overlap occurs if (start1 < end2) AND (start2 < end1)
        return s1_start < s2_end && s2_start < s1_end;
    };

    // Helper to check if a slot is within a range
    const isSlotWithinRange = (slot, range) => {
        if (!slot || !range || !slot.includes('-') || !range.includes('-')) return false;
        try {
            const [slotStart, slotEnd] = slot.split('-').map(parseTimeToMinutes);
            const [rangeStart, rangeEnd] = range.split('-').map(parseTimeToMinutes);
            // Slot is within range if its start is >= range start AND its end is <= range end
            return slotStart >= rangeStart && slotEnd <= rangeEnd;
        } catch(e) {
            console.error("Error parsing time range for validation:", slot, range, e);
            return false; // Fail safely
        }
    };

    // Helper function to parse a date string into a local Date object
    const parseDateStringAsLocal = (dateString) => {
      if (!dateString) return null;
      const parts = dateString.split('-').map(part => parseInt(part, 10));
      return new Date(parts[0], parts[1] - 1, parts[2]);
    };

    const handleCreate = async () => {
        setIsCreating(true);
        try {
            if (!manualData.contractorId || !manualData.settlementName || !manualData.taskType || !manualData.date || !manualData.timeSlot) {
                alert('×™×© ×œ××œ× ××ª ×›×œ ×”×©×“×•×ª ×œ×ª×™××•× ×™×“× ×™.');
                setIsCreating(false);
                return;
            }

            const contractor = contractors.find(c => c.contractor_id === manualData.contractorId);
            const settlement = settlements.find(s => s.name === manualData.settlementName);
            
            if (!contractor) {
                alert('×©×’×™××”: ×§×‘×œ×Ÿ ×œ× × ××¦×.');
                setIsCreating(false);
                return;
            }

            if (!settlement) {
                alert('×©×’×™××”: ×™×™×©×•×‘ ×œ× × ××¦×.');
                setIsCreating(false);
                return;
            }
            
            // 1. Check for existing appointment overlaps
            const existingAppointmentsOnDate = appointments.filter(apt => 
                apt.contractor_id === manualData.contractorId && 
                apt.appointment_date === manualData.date &&
                apt.status !== '×‘×•×˜×œ' && apt.status !== '×”×•×©×œ×' // Consider active/planned appointments
            );

            const isOverlapping = existingAppointmentsOnDate.some(apt => 
                checkTimeSlotOverlap(apt.time_slot, manualData.timeSlot)
            );

            if (isOverlapping) {
                alert('×”×ª× ×’×©×•×ª ×‘×ª×™××•×! ×œ×§×‘×œ×Ÿ ×›×‘×¨ ×™×© ×ª×™××•× ×©×—×•×¤×£ ×œ×–××Ÿ ×”××‘×•×§×©. ×× × ×‘×—×¨ ×–××Ÿ ××—×¨.');
                setIsCreating(false);
                return;
            }

            // 2. Check settlement arrival days first
            const selectedDateObj = parseDateStringAsLocal(manualData.date);
            if (!selectedDateObj) {
                alert('×ª××¨×™×š ×©× ×‘×—×¨ ××™× ×• ×ª×§×™×Ÿ.');
                setIsCreating(false);
                return;
            }
            const dayOfWeek = selectedDateObj.getDay(); // 0=Sunday, 6=Saturday
            const dayOfWeekHebrew = ['×', '×‘', '×’', '×“', '×”', '×•', '×©'][dayOfWeek];
            
            // Check if settlement allows arrivals on this day
            if (settlement.arrival_days && settlement.arrival_days.length > 0) {
                if (!settlement.arrival_days.includes(dayOfWeekHebrew)) {
                    const allowedDays = settlement.arrival_days.join(', ');
                    alert(`×”×™×™×©×•×‘ "${settlement.name}" ××™× ×• ××§×‘×œ ×”×’×¢×•×ª ×‘×™×•× ${dayOfWeekHebrew}. ×™××™ ×”×”×’×¢×” ×”××•×ª×¨×™×: ${allowedDays}`);
                    setIsCreating(false);
                    return;
                }
            }

            // 3. Check for contractor availability rules
            const specificAvailabilities = contractorAvailabilities.filter(av => 
                av.contractor_id === manualData.contractorId && 
                av.settlement_name === manualData.settlementName
            );

            let isAvailable = false;
            let availabilityReason = "";
            let usedAvailabilityRule = "";

            if (specificAvailabilities.length > 0) {
                // Check against specific availabilities - find one that matches this day
                const matchingAvailability = specificAvailabilities.find(av => 
                    av.days_of_week?.includes(dayOfWeekHebrew)
                );

                if (!matchingAvailability) {
                    const allSpecificDays = [...new Set(specificAvailabilities.flatMap(av => av.days_of_week || []))];
                    availabilityReason = `×”×§×‘×œ×Ÿ ××™× ×• ×–××™×Ÿ ×‘×™×™×©×•×‘ ×–×” ×‘×™×•× ${dayOfWeekHebrew} (×”×–××™× ×•×ª ×”×¡×¤×¦×™×¤×™×ª ×”×™× ×œ×™××™×: ${allSpecificDays.join(', ') || '×œ× ××•×’×“×¨×™×'}).`;
                } else {
                    // Day is correct, now check time
                    if (isSlotWithinRange(manualData.timeSlot, matchingAvailability.time_range)) {
                        isAvailable = true;
                        usedAvailabilityRule = `×–××™× ×•×ª ×¡×¤×¦×™×¤×™×ª: ${matchingAvailability.days_of_week?.join(',')} ×‘×©×¢×•×ª ${matchingAvailability.time_range}`;
                    } else {
                        availabilityReason = `×”×§×‘×œ×Ÿ ×–××™×Ÿ ×‘×™×™×©×•×‘ ×–×” ×‘×™×•× ${dayOfWeekHebrew} ×¨×§ ×‘×©×¢×•×ª ${matchingAvailability.time_range}.`;
                    }
                }
            } else {
                // No specific availability - check against default availability
                if (contractor.default_hours) {
                     if (isSlotWithinRange(manualData.timeSlot, contractor.default_hours)) {
                        isAvailable = true;
                        usedAvailabilityRule = `×–××™× ×•×ª ×‘×¨×™×¨×ª ××—×“×œ: ${contractor.default_hours}`;
                    } else {
                        availabilityReason = `×©×¢×•×ª ×”×¤×¢×™×œ×•×ª ×©×œ ×”×§×‘×œ×Ÿ ×œ×¤×™ ×‘×¨×™×¨×ª ××—×“×œ ×”×Ÿ ${contractor.default_hours}.`;
                    }
                } else {
                    availabilityReason = '×œ×§×‘×œ×Ÿ ××™×Ÿ ×©×¢×•×ª ×–××™× ×•×ª ××•×’×“×¨×•×ª ×›×œ×œ. × × ×œ×”×’×“×™×¨ ×–××™× ×•×ª ×œ×§×‘×œ×Ÿ ×–×”.';
                }
            }

            if (!isAvailable) {
                alert(`×œ× × ×™×ª×Ÿ ×œ×§×‘×•×¢ ×ª×™××•× ×™×“× ×™. ${availabilityReason}\n\n×ª×™××•× ×–×” ×“×•×¨×© ×”×ª×¢×¨×‘×•×ª. × ×™×ª×Ÿ ×œ×”××©×™×š ×¨×§ ×× ×‘×¨×•×¨ ×©×”×§×‘×œ×Ÿ ××›×Ÿ ×™×›×•×œ ×œ×‘×¦×¢ ××ª ×”××©×™××” ×‘×–××Ÿ ×–×”.`);
                setIsCreating(false);
                return;
            }

            // All checks passed, create appointment
            await Appointment.create({
                settlement_name: manualData.settlementName,
                task_type: manualData.taskType,
                contractor_id: manualData.contractorId,
                contractor_name: contractor?.name || '×œ× ×™×“×•×¢',
                appointment_date: manualData.date,
                time_slot: manualData.timeSlot,
                status: '××ª×•×›× ×Ÿ',
                manager_approval: true, // Manual appointments are always with manager approval
                notes: `×ª×™××•× ×™×“× ×™ ×¢"×™ ×× ×”×œ. ${usedAvailabilityRule}`
            });
            alert('×”×ª×™××•× ×”×™×“× ×™ × ×•×¦×¨ ×‘×”×¦×œ×—×”!');
            onAppointmentCreated(); // Redirect to calendar or refresh data
        } catch (error) {
            console.error("×©×’×™××” ×‘×™×¦×™×¨×ª ×ª×™××•× ×™×“× ×™:", error);
            alert('×©×’×™××” ×‘×™×¦×™×¨×ª ×”×ª×™××•×. × × ×œ× ×¡×•×ª ×©×•×‘.');
        } finally {
            setIsCreating(false);
        }
    };

    return (
        <Card className="bg-red-50 border-red-200">
            <CardHeader>
                <CardTitle className="text-red-700">×ª×™××•× ×™×“× ×™ (×× ×”×œ)</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
                <div>
                    <Label htmlFor="manualContractor">×‘×—×¨ ×§×‘×œ×Ÿ</Label>
                    <Select onValueChange={(val) => setManualData(d => ({...d, contractorId: val}))} value={manualData.contractorId}>
                        <SelectTrigger id="manualContractor"><SelectValue placeholder="×‘×—×¨ ×§×‘×œ×Ÿ" /></SelectTrigger>
                        <SelectContent>
                            {contractors.filter(c => c.contractor_id && c.name).map(c => (
                                <SelectItem key={c.id} value={c.contractor_id}>{c.name}</SelectItem>
                            ))}
                        </SelectContent>
                    </Select>
                </div>
                <div>
                    <Label htmlFor="manualSettlement">×‘×—×¨ ×™×™×©×•×‘</Label>
                    <Select onValueChange={(val) => setManualData(d => ({...d, settlementName: val}))} value={manualData.settlementName}>
                        <SelectTrigger id="manualSettlement"><SelectValue placeholder="×‘×—×¨ ×™×™×©×•×‘" /></SelectTrigger>
                        <SelectContent>
                            {settlements.filter(s => s.name).map(s => (
                                <SelectItem key={s.id} value={s.name}>{s.name}</SelectItem>
                            ))}
                        </SelectContent>
                    </Select>
                </div>
                <div>
                    <Label htmlFor="manualTaskType">×‘×—×¨ ×¡×•×’ ×¤×§"×¢</Label>
                    <Select onValueChange={(val) => setManualData(d => ({...d, taskType: val}))} value={manualData.taskType}>
                        <SelectTrigger id="manualTaskType">
                            <SelectValue placeholder="×‘×—×¨ ×¡×•×’ ×¤×§&quot;×¢" />
                        </SelectTrigger>
                        <SelectContent>
                            {taskTypes.filter(t => t.type_name).map(t => (
                                <SelectItem key={t.id} value={t.type_name}>{t.type_name}</SelectItem>
                            ))}
                        </SelectContent>
                    </Select>
                </div>
                <div>
                    <Label htmlFor="manualDate">×ª××¨×™×š</Label>
                    <Input id="manualDate" type="date" value={manualData.date} onChange={(e) => setManualData(d => ({...d, date: e.target.value}))}/>
                </div>
                <div>
                    <Label htmlFor="manualTimeSlot">×©×¢×•×ª</Label>
                    <Input id="manualTimeSlot" type="text" placeholder="×©×¢×•×ª, ×œ××©×œ 08:00-10:00" value={manualData.timeSlot} onChange={(e) => setManualData(d => ({...d, timeSlot: e.target.value}))} />
                </div>
                <Button onClick={handleCreate} disabled={isCreating} className="w-full bg-red-600 hover:bg-red-700">
                    {isCreating ? <><Loader2 className="mr-2 h-4 w-4 animate-spin"/>×™×•×¦×¨...</> : '×¦×•×¨ ×ª×™××•× ×‘×›×¤×™×™×”'}
                </Button>
            </CardContent>
        </Card>
    );
};

// ×—×™×©×•×‘ ××¨×—×§ ×‘×™×Ÿ ×©×ª×™ × ×§×•×“×•×ª - Unchanged
const calculateDistance = (lat1, lon1, lat2, lon2) => {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
};

// ×¤×•× ×§×¦×™×” ×œ×¤×•×¨××˜ ×ª××¨×™×š ××§×•××™ ×œ×œ× ×”×–×–×•×ª timezone
const formatDateLocal = (d) => {
  const tzOffset = d.getTimezoneOffset() * 60000;
  return new Date(d.getTime() - tzOffset).toISOString().split('T')[0];
};

// ×¤×•× ×§×¦×™×” ×œ×”×•×¡×¤×ª ×™××™ ×¢×¡×§×™× ×œ×ª××¨×™×š
const addBusinessDays = (startDate, days, blackoutDatesSet) => {
  let currentDate = new Date(startDate);
  let addedDays = 0;
  
  while (addedDays < days) {
    currentDate.setDate(currentDate.getDate() + 1);
    const dayOfWeek = currentDate.getDay(); // 0=Sunday, 6=Saturday - ×ª×™×§×•×Ÿ timezone
    const dateString = formatDateLocal(currentDate);

    // ×“×œ×’ ×¢×œ ×©×™×©×™, ×©×‘×ª ××• ×™××™ ×—×’/×©×‘×ª×•×Ÿ
    if (dayOfWeek !== 5 && dayOfWeek !== 6 && !blackoutDatesSet.has(dateString)) {
      addedDays++;
    }
  }
  return currentDate;
};

// ×¤×•× ×§×¦×™×” ×œ××¦×™××ª ×™×•× ×”×¢×¡×§×™× ×”×‘×
const getNextBusinessDay = (fromDate, blackoutDatesSet) => {
  let currentDate = new Date(fromDate);
  
  // ×”×ª×—×œ ××”×™×•× ×©××—×¨×™ fromDate
  while (true) {
    currentDate.setDate(currentDate.getDate() + 1);
    const dayOfWeek = currentDate.getDay(); // 0=Sunday, 6=Saturday - ×ª×™×§×•×Ÿ timezone
    const dateString = formatDateLocal(currentDate);
    
    // ×× ×–×” ×œ× ×©×™×©×™/×©×‘×ª ×•×œ× ×—×’ - ×–×” ×™×•× ×¢×¡×§×™× ×ª×§×™×Ÿ
    if (dayOfWeek !== 5 && dayOfWeek !== 6 && !blackoutDatesSet.has(dateString)) {
      break;
    }
  }
  
  return currentDate;
};

// Helper function to parse HH:MM string to minutes from midnight
const parseTimeToMinutes = (timeStr) => {
  const [hours, minutes] = timeStr.split(':').map(Number);
  return hours * 60 + minutes;
};

// ×¤×•× ×§×¦×™×” ×œ×‘×“×™×§×ª ×—×¤×™×¤×ª ×–×× ×™× - ×—×™×™×‘×ª ×œ×”×™×•×ª ×œ×¤× ×™ generateContractorSlots
const checkTimeSlotOverlap = (slot1, slot2) => {
  const [s1_start_str, s1_end_str] = slot1.split('-');
  const [s2_start_str, s2_end_str] = slot2.split('-');

  const s1_start = parseTimeToMinutes(s1_start_str);
  const s1_end = parseTimeToMinutes(s1_end_str);
  const s2_start = parseTimeToMinutes(s2_start_str);
  const s2_end = parseTimeToMinutes(s2_end_str);

  // Overlap occurs if (start1 < end2) AND (start2 < end1)
  return s1_start < s2_end && s2_start < s1_end;
};

// ×¤×•× ×§×¦×™×” ×œ×™×¦×™×¨×ª ×ª××¨×™×š ××§×•××™ ××ª×•×š ××—×¨×•×–×ª ×ª××¨×™×š, ××˜×¤×œ×ª ×‘×‘×¢×™×•×ª timezone
const parseDateStringAsLocal = (dateString) => {
  if (!dateString) return null;
  // ×§×œ×˜ ××¡×•×’ date input ×”×•× ×ª××™×“ ×‘×¤×•×¨××˜ YYYY-MM-DD
  const parts = dateString.split('-').map(part => parseInt(part, 10));
  // ×™×¦×™×¨×ª ×ª××¨×™×š ×œ×¤×™ ×–××Ÿ ××§×•××™ ×›×“×™ ×œ×× ×•×¢ ×”×–×–×•×ª timezone
  // new Date(year, monthIndex, day)
  return new Date(parts[0], parts[1] - 1, parts[2]);
};


// ××œ×’×•×¨×™×ª× ×”×ª×™××•× ×”×—×›× ×”××ª×§×“×
const getSmartScheduling = async (params, settlements, contractors, contractorAvailabilities, appointments, taskTypes, blackoutDates) => {
  const { settlementId, taskTypeId, managerApproval, specificDate } = params;
  
  const settlement = settlements.find(s => s.id === settlementId);
  const taskType = taskTypes.find(t => t.id === taskTypeId);
  
  if (!settlement || !taskType) {
    console.log("âŒ ×œ× × ××¦× ×™×™×©×•×‘ ××• ×¡×•×’ ×¤×§\"×¢");
    return [];
  }

  const blackoutDatesSet = new Set(blackoutDates.map(d => d.date));
  const activeAppointments = appointments.filter(apt => apt.status !== '×‘×•×˜×œ');
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  let searchStartDate;
  if (specificDate) {
    searchStartDate = parseDateStringAsLocal(specificDate);
    if (!searchStartDate) {
      console.error("âŒ ×ª××¨×™×š ×¡×¤×¦×™×¤×™ ×œ× ×ª×§×™×Ÿ:", specificDate);
      return [];
    }

    const slaDeadline = addBusinessDays(today, taskType.sla_days, blackoutDatesSet);
    if (!managerApproval && searchStartDate <= slaDeadline) {
      return [{ requiresManagerApproval: true }];
    }
  } else {
    searchStartDate = getNextBusinessDay(today, blackoutDatesSet);
  }
  
  let searchEndDate;
  if (specificDate) {
    searchEndDate = new Date(searchStartDate);
  } else {
    const slaDeadline = addBusinessDays(today, taskType.sla_days, blackoutDatesSet);
    searchEndDate = slaDeadline;
  }
  searchEndDate.setHours(23, 59, 59, 999);
  searchStartDate.setHours(0,0,0,0);


  // 1. ×¡×™× ×•×Ÿ ×§×‘×œ× ×™× ×©×–×›××™× ×’××•×’×¨×¤×™×ª ×•×ª×¤×§×•×“×™×ª
  const eligibleContractors = contractors.filter(c => {
    const isGeographicallyCovered = 
        c.regions?.includes(settlement.region) ||
        c.sub_regions?.includes(settlement.sub_region) ||
        c.priority_settlements?.includes(settlement.name);

    const isTaskEligible = managerApproval || c.task_types?.includes(taskType.type_name);

    return c.active && isTaskEligible && isGeographicallyCovered;
  });

  if (eligibleContractors.length === 0) {
    console.log("âŒ ×œ× × ××¦××• ×§×‘×œ× ×™× ×–×›××™× ×œ×™×™×©×•×‘ ×•×œ×¡×•×’ ×”×¤×§\"×¢");
    return [];
  }

  // ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×œ×—×™×©×•×‘ ××¨×—×§ ×‘×™××™×
  const daysBetween = (date1, date2) => {
    const oneDay = 1000 * 60 * 60 * 24;
    return Math.round(Math.abs((date1.getTime() - date2.getTime()) / oneDay));
  };
  
  // ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×œ×™×¦×™×¨×ª ×•×“×™×¨×•×’ ×¡×œ×•×˜×™× ×¢×‘×•×¨ ×§×‘×œ×Ÿ - IMPROVED
  const generateAndScoreSlotsForContractor = (contractor) => {
    const scoredSlots = [];
    let currentDate = new Date(searchStartDate);
    
    const contractorAppointmentsByDate = activeAppointments
      .filter(apt => apt.contractor_id === contractor.contractor_id)
      .reduce((acc, apt) => {
        (acc[apt.appointment_date] = acc[apt.appointment_date] || []).push(apt);
        return acc;
      }, {});

    while (currentDate <= searchEndDate) {
      const dayOfWeek = currentDate.getDay();
      const currentDateStr = formatDateLocal(currentDate);

      const isWeekend = dayOfWeek === 5 || dayOfWeek === 6;
      const isBlackout = blackoutDatesSet.has(currentDateStr);
      if ((isWeekend || isBlackout) && !managerApproval) {
        currentDate.setDate(currentDate.getDate() + 1);
        continue;
      }
      
      const dayOfWeekHebrew = ['×', '×‘', '×’', '×“', '×”', '×•', '×©'][dayOfWeek];
      
      // *** FIXED: Check settlement arrival days first ***
      if (settlement.arrival_days && settlement.arrival_days.length > 0) {
        if (!settlement.arrival_days.includes(dayOfWeekHebrew)) {
          console.log(`ğŸš« ×™×™×©×•×‘ ${settlement.name} ××™× ×• ××§×‘×œ ×”×’×¢×•×ª ×‘×™×•× ${dayOfWeekHebrew}`);
          currentDate.setDate(currentDate.getDate() + 1);
          continue;
        }
      }
      
      // *** FIXED: Use filter instead of find for multiple availability records ***
      const specificAvailabilities = contractorAvailabilities.filter(av => 
          av.contractor_id === contractor.contractor_id && 
          av.settlement_name === settlement.name
      );

      let availableHours = null;
      let reasonForHours = "";

      if (specificAvailabilities.length > 0) {
          // Check if any of the specific availabilities include this day
          const matchingAvailability = specificAvailabilities.find(av => 
              av.days_of_week?.includes(dayOfWeekHebrew)
          );

          if (matchingAvailability) {
              availableHours = matchingAvailability.time_range;
              reasonForHours = "×–××™× ×•×ª ×¡×¤×¦×™×¤×™×ª ×œ×™×™×©×•×‘";
          } else {
              // None of the specific availabilities include this day for this date
              const allSpecificDays = [...new Set(specificAvailabilities.flatMap(av => av.days_of_week || []))];
              console.log(`ğŸš« ${contractor.name} ×œ× ×–××™×Ÿ ×‘-${settlement.name} ×‘×™×•× ${dayOfWeekHebrew} (×–××™× ×•×ª ×¡×¤×¦×™×¤×™×ª: ${allSpecificDays.join(', ') || '×œ× ××•×’×“×¨×™×'})`);
              currentDate.setDate(currentDate.getDate() + 1);
              continue;
          }
      } else {
          // No specific availability - use default hours
          availableHours = contractor.default_hours;
          reasonForHours = "×–××™× ×•×ª ×‘×¨×™×¨×ª ××—×“×œ";
      }

      // ×× ××™×Ÿ ×©×¢×•×ª ×–××™× ×•×ª (×™×›×•×œ ×œ×§×¨×•×ª ×× ×œ× ××•×’×“×¨×•×ª ×©×¢×•×ª ×‘×¨×™×¨×ª ××—×“×œ), ×“×œ×’ ×¢×œ ×”×™×•×
      if (!availableHours) {
        currentDate.setDate(currentDate.getDate() + 1);
        continue;
      }

      const [start, end] = availableHours.split('-');
      if (!start || !end) { // Ensure time range is valid
        currentDate.setDate(currentDate.getDate() + 1);
        continue;
      }

      const startHour = parseInt(start.split(':')[0]);
      const endHour = parseInt(end.split(':')[0]);

      for (let hour = startHour; hour <= endHour - 2; hour++) { // Assuming 2-hour slots
        const slotTime = `${String(hour).padStart(2, '0')}:00-${String(hour + 2).padStart(2, '0')}:00`;
        const isBusy = contractorAppointmentsByDate[currentDateStr]?.some(apt => checkTimeSlotOverlap(apt.time_slot, slotTime));
        
        if (!isBusy) {
            // ×“×™×¨×•×’ ×”×¡×œ×•×˜
            let slotScore = 100;
            slotScore -= daysBetween(searchStartDate, currentDate); // ×¢×“×™×¤×•×ª ×œ×ª××¨×™×›×™× ×§×¨×•×‘×™×
            if (hour < 12) slotScore += 10; // ×‘×•× ×•×¡ ×œ×‘×•×§×¨
            // This bonus could be tricky if it conflicts with real availability needs.
            // Consider if a contractor is 'working' on a day but only has one appt - this bonus makes sense.
            if (contractorAppointmentsByDate[currentDateStr] && contractorAppointmentsByDate[currentDateStr].length > 0) slotScore += 50; // ×‘×•× ×•×¡ ×œ× ×™×¦×•×œ ×™×•×

            scoredSlots.push({ date: currentDateStr, time: slotTime, score: slotScore });
        }
      }
      
      currentDate.setDate(currentDate.getDate() + 1);
    }
    // ×”×—×–×¨×ª ×›×œ ×”×¡×œ×•×˜×™× ×××•×™× ×™× ×œ×¤×™ ×”×¦×™×•×Ÿ ×©×œ×”×
    return scoredSlots.sort((a, b) => b.score - a.score);
  };

  // 2. ×—×™×©×•×‘ ×¦×™×•×Ÿ ×œ×›×œ ×§×‘×œ×Ÿ ×•××™×¡×•×£ ×”×¡×œ×•×˜×™× ×”××•×‘×™×œ×™× ×©×œ×•
  const scoredContractors = eligibleContractors.map(contractor => {
    let score = 100;
    let reasons = [];

    // ×¦×™×•×Ÿ ×’××•×’×¨×¤×™
    if (contractor.priority_settlements?.includes(settlement.name)) {
      score += 200; reasons.push('×§×‘×œ×Ÿ ×™×™×¢×•×“×™ ×œ×™×™×©×•×‘');
    } else if (settlement.sub_region && contractor.sub_regions?.includes(settlement.sub_region)) {
      score += 150; reasons.push('××ª××—×” ×‘×ª×ª-××–×•×¨');
    } else if (settlement.region && contractor.regions?.includes(settlement.region)) {
      score += 100; reasons.push('××ª××—×” ×‘××–×•×¨');
    }
    
    // ×¦×™×•×Ÿ ×¢×“×™×¤×•×ª
    const priorityScores = { '×’×‘×•×”': 50, '×¨×’×™×œ': 25, '× ××•×š': 0 };
    score += priorityScores[contractor.priority] || 10; // Default to 10 if priority is undefined or '× ××•×š'
    if((priorityScores[contractor.priority] || 0) > 0) reasons.push(`×¢×“×™×¤×•×ª ${contractor.priority}`);

    const allAvailableSlots = generateAndScoreSlotsForContractor(contractor);
    
    // ×‘×•× ×•×¡ ×¢×œ × ×™×¦×•×œ ×™×•× ×¢×‘×•×“×” ×§×™×™×
    const contractorAppointmentsByDate = activeAppointments
      .filter(apt => apt.contractor_id === contractor.contractor_id)
      .reduce((acc, apt) => {
        (acc[apt.appointment_date] = acc[apt.appointment_date] || []).push(apt);
        return acc;
      }, {});

    if (allAvailableSlots.some(slot => contractorAppointmentsByDate[slot.date] && contractorAppointmentsByDate[slot.date].length > 0)) {
        score += 100;
        reasons.push('× ×™×¦×•×œ ×™×•× ×¢×‘×•×“×”');
    }
    
    return {
      contractor,
      score: Math.max(0, Math.round(score)),
      reasons: [...new Set(reasons)], // Ensure unique reasons
      slots: allAvailableSlots.slice(0, 3) // ×”×¦×’ ×¢×“ 3 ×¡×œ×•×˜×™× ××•×¢×“×¤×™×
    };
  }).filter(c => c.slots.length > 0); // ×¡× ×Ÿ ×”×—×•×¦×” ×§×‘×œ× ×™× ×œ×œ× ×¡×œ×•×˜×™× ×–××™× ×™×

  // 3. ××™×•×Ÿ ×¡×•×¤×™ ×©×œ ×”×§×‘×œ× ×™× ×•×”×—×–×¨×ª 3 ×”××•×‘×™×œ×™×
  return scoredContractors.sort((a, b) => b.score - a.score).slice(0, 3);
};

export default function Scheduling() {
  const { user, loading: userLoading, isAdmin } = usePermissions(); // Updated: use usePermissions hook
  const [settlements, setSettlements] = useState([]);
  const [taskTypes, setTaskTypes] = useState([]);
  const [contractors, setContractors] = useState([]);
  const [contractorAvailabilities, setContractorAvailabilities] = useState([]);
  const [appointments, setAppointments] = useState([]);
  const [blackoutDates, setBlackoutDates] = useState([]);
  const [loading, setLoading] = useState(true); // This loading state is for initial data fetch, distinct from userLoading

  // Form state
  const [selectedSettlement, setSelectedSettlement] = useState('');
  const [selectedTaskType, setSelectedTaskType] = useState('');
  const [taskNumber, setTaskNumber] = useState('');
  const [managerApproval, setManagerApproval] = useState(false);
  const [selectedDate, setSelectedDate] = useState('');

  // Results state
  const [isSearching, setIsSearching] = useState(false);
  const [suggestedContractors, setSuggestedContractors] = useState([]); // This will now hold the enriched contractor objects
  const [error, setError] = useState(null);
  const [showManagerApprovalAlert, setShowManagerApprovalAlert] = useState(false);
  const [submittedSearch, setSubmittedSearch] = useState(false); // New state to track if a search was submitted

  useEffect(() => {
    // Only load initial data if user permissions are loaded and user exists
    if (!userLoading && user) {
        loadInitialData();
    } else if (!userLoading && !user) {
        // If user is not logged in, set loading to false to show login message
        setLoading(false);
    }
  }, [user, userLoading]); // Depend on user and userLoading

  const loadInitialData = async () => {
    setLoading(true);
    try {
      const [settlementData, taskTypeData, contractorData, availabilityData, appointmentData, blackoutData] = await Promise.all([
        Settlement.list(),
        TaskType.list(),
        Contractor.list(),
        ContractorAvailability.list(),
        Appointment.list(),
        BlackoutDate.list(),
      ]);
      setSettlements(settlementData);
      setTaskTypes(taskTypeData);
      setContractors(contractorData);
      setContractorAvailabilities(availabilityData);
      setAppointments(appointmentData);
      setBlackoutDates(blackoutData);
    } catch (err) {
      console.error("Failed to load initial data", err);
      setError("×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™× ×‘×¡×™×¡×™×™×. × × ×œ×¨×¢× ×Ÿ ××ª ×”×¢××•×“.");
    }
    setLoading(false);
  };
  
  const redirectToCalendar = () => {
      window.location.href = createPageUrl('Calendar');
  }

  const handleSearchSlots = async () => {
    if (!selectedSettlement || !selectedTaskType) {
      setError("× × ×œ×‘×—×•×¨ ×™×™×©×•×‘ ×•×¡×•×’ ×¤×§\"×¢.");
      return;
    }

    // ×‘×“×™×§×ª ×”×¨×©××•×ª ×œ×ª××¨×™×š ×¡×¤×¦×™×¤×™
    if (selectedDate && !isAdmin) { // Check if a specific date is selected and user is not admin
      const selectedDateObj = parseDateStringAsLocal(selectedDate);
      const today = new Date();
      today.setHours(0, 0, 0, 0); // Normalize today to start of day for accurate comparison
      
      if (!selectedDateObj || selectedDateObj <= today) { // If selected date is today or in the past
        setError("××©×ª××©×™× ×¨×’×™×œ×™× ×™×›×•×œ×™× ×œ×‘×—×•×¨ ×¨×§ ×ª××¨×™×›×™× ×¢×ª×™×“×™×™×. ×‘×—×¨ ×ª××¨×™×š ××—×¨ ×•××™×œ×š.");
        return;
      }
    }
    
    setError(null);
    setShowManagerApprovalAlert(false);
    setIsSearching(true);
    setSuggestedContractors([]);
    setSubmittedSearch(true); // Mark that a search has been initiated
    
    try {
      const [freshSettlements, freshContractors, freshAvailabilities, freshAppointments, freshBlackoutDates] = await Promise.all([
        Settlement.list(),
        Contractor.list(),
        ContractorAvailability.list(),
        Appointment.list(),
        BlackoutDate.list()
      ]);
      
      const params = {
        settlementId: selectedSettlement,
        taskTypeId: selectedTaskType,
        managerApproval,
        specificDate: selectedDate || null
      };
      const results = await getSmartScheduling(
        params, 
        freshSettlements, 
        freshContractors, 
        freshAvailabilities, 
        freshAppointments, 
        taskTypes,
        freshBlackoutDates
      );

      if (results.length === 1 && results[0].requiresManagerApproval) {
        setShowManagerApprovalAlert(true);
        setSuggestedContractors([]);
      } else {
        setSuggestedContractors(results);
      }

    } catch (err) {
      console.error("Error finding slots:", err);
      setError("×©×’×™××” ×‘××¦×™××ª ×ª×™××•××™×. × × ×œ× ×¡×•×ª ×©×•×‘.");
    } finally {
      setIsSearching(false);
    }
  };

  const handleSelectSlot = async (contractorFullObject, slot) => {
    const settlement = settlements.find(s => s.id === selectedSettlement);
    const taskType = taskTypes.find(t => t.id === selectedTaskType);
    
    // Use the contractor_id and name from the full contractor object
    const contractorId = contractorFullObject.contractor_id;
    const contractorName = contractorFullObject.name;

    try {
      const currentAppointments = await Appointment.list();
      const conflictingAppointment = currentAppointments.find(apt => 
        apt.contractor_id === contractorId && // Use contractorId
        apt.appointment_date === slot.date &&
        apt.status !== '×‘×•×˜×œ' && apt.status !== '×”×•×©×œ×' &&
        checkTimeSlotOverlap(apt.time_slot, slot.time)
      );

      if (conflictingAppointment) {
        alert(`×”×§×‘×œ×Ÿ ${contractorName} ×›×‘×¨ ×ª×¤×•×¡ ×‘-${slot.date} ×‘×©×¢×•×ª ${conflictingAppointment.time_slot}. × × ×œ×‘×—×•×¨ ××•×¢×“ ××—×¨.`);
        // Refresh suggestions to reflect the newly discovered conflict
        handleSearchSlots(); 
        return;
      }
    } catch (error) {
      console.error('×©×’×™××” ×‘×‘×“×™×§×ª ×–××™× ×•×ª:', error);
      alert('×©×’×™××” ×‘×‘×“×™×§×ª ×–××™× ×•×ª ×”×§×‘×œ×Ÿ. × × ×œ× ×¡×•×ª ×©×•×‘.');
      return;
    }
    
    const confirmMessage = `××™×©×•×¨ ×ª×™××•×:\n\n×™×™×©×•×‘: ${settlement.name}\n×¡×•×’ ×¤×§"×¢: ${taskType.type_name}\n×§×‘×œ×Ÿ: ${contractorName}\n×ª××¨×™×š: ${new Date(slot.date).toLocaleDateString('he-IL')}\n×©×¢×•×ª: ${slot.time}\n\n×œ××©×¨ ×ª×™××•×?`;
    
    if (window.confirm(confirmMessage)) {
      try {
        await Appointment.create({
          settlement_name: settlement.name,
          task_type: taskType.type_name,
          contractor_id: contractorId, // Use contractorId
          contractor_name: contractorName, // Use contractorName
          appointment_date: slot.date,
          time_slot: slot.time,
          status: '××ª×•×›× ×Ÿ',
          notes: taskNumber ? `××¡×¤×¨ ×¤×§"×¢: ${taskNumber}` : '',
          manager_approval: managerApproval
        });

        alert('×”×ª×™××•× × ×•×¦×¨ ×‘×”×¦×œ×—×”!');
        
        redirectToCalendar();
        
      } catch (error) {
        console.error('×©×’×™××” ×‘×™×¦×™×¨×ª ×”×ª×™××•×:', error);
        setError('×©×’×™××” ×‘×™×¦×™×¨×ª ×”×ª×™××•×. × × ×œ× ×¡×•×ª ×©×•×‘.');
      }
    }
  };

  // ×—×™×©×•×‘ ×ª××¨×™×š ××™× ×™××œ×™ ×œ×‘×—×™×¨×”
  const getMinDate = () => {
    const today = new Date();
    // Use formatDateLocal for consistency and to avoid timezone issues with UI
    
    if (isAdmin && managerApproval) { // Updated: use isAdmin
      return formatDateLocal(today); // ×× ×”×œ ×™×›×•×œ ×œ×‘×—×•×¨ ××”×™×•× ×¨×§ ×× ×¡×•××Ÿ "××™×©×•×¨ ×× ×”×œ"
    } else {
      const tomorrow = new Date(today.getTime() + (24 * 60 * 60 * 1000));
      return formatDateLocal(tomorrow); // × ×¦×™×’ ×¨×’×™×œ ××• ×× ×”×œ ×œ×œ× "××™×©×•×¨ ×× ×”×œ" - × tomorrow ×•××™×œ×š ×‘×œ×‘×“
    }
  };

  const renderResults = () => {
    if (isSearching) {
      return (
        <div className="flex flex-col items-center justify-center h-48">
          <Loader2 className="w-12 h-12 animate-spin text-green-600 mb-4" />
          <p className="text-lg text-gray-600 text-center">
            ×”××œ×’×•×¨×™×ª× ×”×—×›× ××—×©×‘ ××ª ×”××¤×©×¨×•×™×•×ª ×”×˜×•×‘×•×ª ×‘×™×•×ª×¨...
          </p>
          <p className="text-sm text-gray-500 mt-2">
            ××ª×—×©×‘ ×‘-SLA, ×¢×“×™×¤×•×™×•×ª ×§×‘×œ× ×™×, ×–××™× ×•×ª ×•× ×™×¦×•×œ ×™××™ ×¢×‘×•×“×”
          </p>
        </div>
      );
    }
    if (error) {
      return (
        <Alert variant="destructive" className="mb-4">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      );
    }
    if (showManagerApprovalAlert) {
      return (
        <Alert variant="destructive" className="mb-4 bg-yellow-50 border-yellow-200 text-yellow-800">
          <ShieldAlert className="h-4 w-4" />
          <AlertTitle>× ×“×¨×© ××™×©×•×¨ ×× ×”×œ</AlertTitle>
          <AlertDescription>
            ×”×ª××¨×™×š ×©× ×‘×—×¨ × ××¦× ×‘×˜×•×•×— ×”-SLA. ×›×“×™ ×œ×—×¤×© ×‘×ª××¨×™×š ×–×”, ×™×© ×œ×¡××Ÿ "××™×©×•×¨ ×× ×”×œ".
          </AlertDescription>
        </Alert>
      );
    }
    if (suggestedContractors.length === 0 && submittedSearch) {
      return (
        <Alert className="mt-4">
          <CalendarX className="h-4 w-4" />
          <AlertTitle>×œ× × ××¦××• ××•×¢×“×™× ×¤× ×•×™×™×</AlertTitle>
          <AlertDescription>
            ×œ× × ××¦××• ×§×‘×œ× ×™× ××• ××•×¢×“×™× ×–××™× ×™× ×”×ª×•×××™× ××ª ×‘×§×©×ª×š. × ×¡×” ×œ×©× ×•×ª ××ª ×”×ª××¨×™×š ××• ×¡×•×’ ×”×¤×§"×¢.
          </AlertDescription>
        </Alert>
      );
    }
    if (suggestedContractors.length > 0) {
      return (
        <div className="space-y-6 pt-4">
          <h3 className="text-2xl font-bold text-center text-gray-800">××•×¢×“×™× ××•××œ×¦×™×</h3>
          {suggestedContractors.map(({ contractor, score, reasons, slots }, index) => (
            <Card key={contractor.id} className="border-green-200 bg-white shadow-lg overflow-hidden">
              <CardHeader className="bg-green-50 p-4 border-b border-green-200">
                <div className="flex justify-between items-center">
                  <div className="flex items-center gap-3">
                    <UserCheck className="w-6 h-6 text-green-700" />
                    <h4 className="text-lg font-bold text-green-800">{contractor.name}</h4>
                  </div>
                  <Badge variant="outline" className="text-green-700 border-green-300 bg-white">
                    <Star className="w-3 h-3 mr-1 text-yellow-500 fill-current" /> ×¦×™×•×Ÿ: {Math.round(score)}
                  </Badge>
                </div>
                <div className="flex flex-wrap gap-2 mt-2">
                  {reasons.map((reason, i) => (
                    <Badge key={i} variant="secondary" className="bg-green-100 text-green-800 text-xs">
                      {reason}
                    </Badge>
                  ))}
                </div>
              </CardHeader>
              <CardContent className="p-4 space-y-3">
                {slots.map((slot, slotIndex) => (
                  <div key={slotIndex} className="flex justify-between items-center p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors">
                    <div className="flex items-center gap-4">
                      <CalendarDays className="w-5 h-5 text-gray-500" />
                      <div>
                          <p className="font-semibold text-gray-800">{new Date(slot.date).toLocaleDateString('he-IL', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</p>
                          <p className="text-sm text-gray-600">{slot.time}</p>
                      </div>
                    </div>
                    <Button onClick={() => handleSelectSlot(contractor, slot)}>
                      ×‘×—×¨ ××•×¢×“
                    </Button>
                  </div>
                ))}
              </CardContent>
            </Card>
          ))}
        </div>
      );
    }
    return (
      <div className="text-center text-gray-500 py-16">
        <CalendarIcon className="w-16 h-16 mx-auto mb-4 text-gray-300" />
        <p className="text-lg mb-2">×”×ª×•×¦××•×ª ×™×•×¤×™×¢×• ×›××Ÿ</p>
        <p className="text-sm">×œ××—×¨ ×‘×—×™×¨×ª ×™×™×©×•×‘ ×•×¡×•×’ ×¤×§"×¢, ×œ×—×¥ ×¢×œ "××¦× ×ª×™××•× ××•×¤×˜×™××œ×™"</p>
      </div>
    );
  };

  if (userLoading || loading) { // Combine both loading states
    return (
      <div className="flex items-center justify-center h-screen">
        <Loader2 className="w-12 h-12 animate-spin text-blue-600" />
      </div>
    );
  }

  if (!user) { // Check if user is logged in
    return (
      <div className="p-6">
        <Alert variant="destructive">
          <ShieldAlert className="h-4 w-4" />
          <AlertTitle>× ×“×¨×©×ª ×”×ª×—×‘×¨×•×ª</AlertTitle>
          <AlertDescription>
            ×¢×œ×™×š ×œ×”×ª×—×‘×¨ ×›×“×™ ×œ×’×©×ª ×œ××¢×¨×›×ª ×”×ª×™××•××™×.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div className="p-6 space-y-6 bg-gradient-to-br from-blue-50 to-green-50 min-h-screen">
      <div className="flex items-center gap-3">
        <div className="w-10 h-10 bg-gradient-to-r from-blue-500 to-green-500 rounded-xl flex items-center justify-center">
          <Wand2 className="w-5 h-5 text-white" />
        </div>
        <div>
          <h1 className="text-3xl font-bold text-gray-900">×ª×™××•× ×˜×›× ××™</h1>
          <p className="text-gray-600 mt-1">××¦× ××ª ×”×ª×™××•× ×”××•×¤×˜×™××œ×™ ××• ×‘×¦×¢ ×ª×™××•× ×™×“× ×™</p>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Input Form Card */}
        <Card className="lg:col-span-1 bg-white/80 backdrop-blur border-blue-200 shadow-lg">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <UserCheck className="w-5 h-5 text-blue-600" />
              ×¤×¨×˜×™ ×”×ª×™××•×
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {isAdmin && ( // Conditional rendering based on isAdmin
              <div className="flex items-center space-x-2 bg-red-50 p-3 rounded-lg border border-red-200">
                <Checkbox 
                  id="managerApproval" 
                  checked={managerApproval} 
                  onCheckedChange={(checked) => {
                      setManagerApproval(checked);
                      if(checked) setShowManagerApprovalAlert(false); // ×”×¡×ª×¨×ª ×”×ª×¨××” ×× ×”×× ×”×œ ××™×©×¨
                  }}
                />
                <Label htmlFor="managerApproval" className="font-bold text-red-600 text-sm">
                  ××™×©×•×¨ ×× ×”×œ (×¢×•×§×£ ×”××œ×¦×•×ª)
                </Label>
              </div>
            )}
            
            {managerApproval ? (
                <ManualScheduler 
                    contractors={contractors} 
                    settlements={settlements} 
                    taskTypes={taskTypes}
                    onAppointmentCreated={redirectToCalendar}
                    appointments={appointments}
                    contractorAvailabilities={contractorAvailabilities}
                />
            ) : (
              <>
                <div>
                  <Label htmlFor="settlement">×™×™×©×•×‘</Label>
                  <Select value={selectedSettlement} onValueChange={setSelectedSettlement}>
                    <SelectTrigger id="settlement">
                      <SelectValue placeholder="×‘×—×¨ ×™×™×©×•×‘" />
                    </SelectTrigger>
                    <SelectContent>
                      {settlements.filter(s => s.id && s.name).map(s => (
                        <SelectItem key={s.id} value={s.id}>
                          <div className="flex items-center gap-2">
                            <span>{s.name}</span>
                            <span className="text-xs text-gray-500">({s.region})</span>
                          </div>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div>
                  <Label htmlFor="taskType">×¡×•×’ ×¤×§"×¢</Label>
                  <Select value={selectedTaskType} onValueChange={setSelectedTaskType}>
                    <SelectTrigger id="taskType">
                      <SelectValue placeholder="×‘×—×¨ ×¡×•×’ ×¤×§&quot;×¢" />
                    </SelectTrigger>
                    <SelectContent>
                      {taskTypes.filter(t => t.id && t.type_name).map(t => (
                        <SelectItem key={t.id} value={t.id}>
                          <div className="flex items-center gap-2">
                            <span>{t.type_name}</span>
                            <span className="text-xs text-gray-500">({t.duration_minutes} ×“×§×³)</span>
                          </div>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div>
                  <Label htmlFor="taskNumber">××¡×¤×¨ ×¤×§"×¢ (××•×¤×¦×™×•× ×œ×™)</Label>
                  <Input 
                    id="taskNumber" 
                    value={taskNumber} 
                    onChange={(e) => setTaskNumber(e.target.value)} 
                    placeholder="×œ×“×•×’××”: 123456" 
                  />
                </div>
                <div>
                  <Label htmlFor="selectedDate">×ª××¨×™×š ×¡×¤×¦×™×¤×™ (××•×¤×¦×™×•× ×œ×™)</Label>
                  <Input 
                    id="selectedDate"
                    type="date"
                    value={selectedDate} 
                    onChange={(e) => setSelectedDate(e.target.value)}
                    min={getMinDate()}
                    className="bg-white"
                  />
                  <p className="text-xs text-gray-500 mt-1">
                    {selectedDate ? '×—×™×¤×•×© ×œ×ª××¨×™×š ×¡×¤×¦×™×¤×™' : '×—×™×¤×•×© ×›×œ×œ×™ ×œ×©×‘×•×¢×™×™× ×”×§×¨×•×‘×™×'}
                  </p>
                </div>
                <Button onClick={handleSearchSlots} disabled={isSearching} className="w-full bg-gradient-to-r from-blue-600 to-green-600 hover:from-blue-700 hover:to-green-700">
                  {isSearching ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      ××—×¤×©...
                    </>
                  ) : (
                    <>
                      <Sparkles className="mr-2 h-4 w-4" />
                      ××¦× ×ª×™××•× ××•×¤×˜×™××œ×™
                    </>
                  )}
                </Button>
              </>
            )}
          </CardContent>
        </Card>

        {/* Results Card */}
        <Card className={`lg:col-span-2 bg-white/80 backdrop-blur border-green-200 shadow-lg min-h-[400px] ${managerApproval ? 'hidden lg:block' : ''}`}>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <CalendarIcon className="w-5 h-5 text-green-600" />
              ××•×¢×“×™× ××•××œ×¦×™×
            </CardTitle>
          </CardHeader>
          <CardContent>
            {renderResults()}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
